# -*- coding: utf-8 -*-
"""Python_para_Data_Science_Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GyIcs9gLBFEuEFG4GXFVUa2POe2Gtttc

# <font color=green> PYTHON PARA DATA SCIENCE - PANDAS
---

# <font color=green> 1. INTRODUÇÃO AO PYTHON
---

# 1.1 Introdução

> Python é uma linguagem de programação de alto nível com suporte a múltiplos paradigmas de programação. É um projeto *open source* e desde seu surgimento, em 1991, vem se tornando uma das linguagens de programação interpretadas mais populares.
>
> Nos últimos anos Python desenvolveu uma comunidade ativa de processamento científico e análise de dados e vem se destacando como uma das linguagens mais relevantes quando o assundo é ciência de dados e machine learning, tanto no ambiente acadêmico como também no mercado.

# 1.2 Instalação e ambiente de desenvolvimento

### Instalação Local

### https://www.python.org/downloads/
### ou
### https://www.anaconda.com/distribution/

### Google Colaboratory

### https://colab.research.google.com

### Verificando versão
"""

!python -V

"""# 1.3 Trabalhando com dados"""

import pandas as pd
#pd.set_option('display.max_rows', 10)
#pd.set_option('display.max_columns', 10)
#forma de manipular a exibição do dataframe, o ultimo numero pode ser qualquer um

dataset = pd.read_csv('db.csv', sep = ';')
dataset

dataset.dtypes
#No Pandas, todo valor do tipo string é tratado como object

dataset[['Quilometragem', 'Valor']].describe()
#passa as estatísticas descritivas



"""# <font color=green> 2. TRABALHANDO COM TUPLAS
---

# 2.1 Criando tuplas

Tuplas são sequências imutáveis que são utilizadas para armazenar coleções de itens, geralmente heterogêneos. Podem ser construídas de várias formas:
```
- Utilizando um par de parênteses: ( )
- Utilizando uma vírgula à direita: x,
- Utilizando um par de parênteses com itens separados por vírgulas: ( x, y, z )
- Utilizando: tuple() ou tuple(iterador)
```
"""

['Jetta Variant', 'Passat', 'Crossfox', 'DS5']

"""# 2.2 Seleções em tuplas"""

nomes_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5', ('Fusca', 'Gol', 'C4'))
nomes_carros

carros = (
    (
        'Jetta Variant',
        'Motor 4.0 Turbo',
        2003,
        False,
        ('Rodas de liga', 'Travas elétricas', 'Piloto automático')
    ),
    (
        'Passat',
        'Motor Diesel',
        1991,
        True,
        ('Central multimídia', 'Teto panorâmico', 'Freios ABS')
    )
)

for tupla in carros:
  for item in tupla[-1]:
    print(item)
#para retornar apenas os itens desse índice, utilizar as listas de acessórios como iterador

"""# 2.3 Iterando em tuplas"""

nomes_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5')
nomes_carros

"""### Desempacotamento de tuplas"""



"""## *zip()*

https://docs.python.org/3.6/library/functions.html#zip
"""

carros = ['Jetta Variant', 'Passat', 'Crossfox', 'DS5']
carros

valores = [88078.64, 106161.94, 72832.16, 124549.07]
valores

"""# <font color=green> 3. TRABALHANDO COM DICIONÁRIOS
---

# 3.1 Criando dicionários

Listas são coleções sequenciais, isto é, os itens destas sequências estão ordenados e utilizam índices (números inteiros) para acessar os valores.

Os dicionários são coleções um pouco diferentes. São estruturas de dados que representam um tipo de mapeamento. Mapeamentos são coleções de associações entre pares de valores onde o primeiro elemento do par é conhecido como chave (*key*) e o segundo como valor (*value*).

```
dicionario = {key_1: value_1, key_2: value_2, ..., key_n: value_n}
```

https://docs.python.org/3.6/library/stdtypes.html#typesmapping
"""

carros = ['Jetta Variant', 'Passat', 'Crossfox']
carros

valores = [88078.64, 106161.94, 72832.16]
valores

dados = {
    'Passat': {
        'ano': 2012,
        'km': 50000,
        'valor': 75000,
        'acessorios': ['Airbag', 'ABS']
    },
    'Crossfox': {
        'ano': 2015,
        'km': 35000,
        'valor': 25000
    }
}

'acessorios' in dados['Crossfox']
'acessorios' in dados['Passat']
dados['Crossfox']['valor']
dados['Passat']['acessorios'][-1]

"""### Criando dicionários com *zip()*"""



"""# 3.2 Operações com dicionários

## *dict[ key ]*

Retorna o valor correspondente à chave (*key*) no dicionário.
"""



"""## *key in dict*

Retorna **True** se a chave (*key*) for encontrada no dicionário.
"""







"""## *len(dict)*

Retorna o número de itens do dicionário.
"""



"""## *dict[ key ] = value*

Inclui um item ao dicionário.
"""



"""## *del dict[ key ]*

Remove o item de chave (*key*) do dicionário.
"""



"""# 3.3 Métodos de dicionários

## *dict.update()*

Atualiza o dicionário.
"""

dadoss = {'Crossfox': 72832.16, 'DS5': 124549.07, 'Jetta Variant': 88078.64}
dadoss

dadoss.update({'Passat': 106161.94})
dadoss

"""## *dict.copy()*

Cria uma cópia do dicionário.
"""

dadosCopy = dadoss

#Se criarmos uma variável dadosCopy e atribuirmos a ela o dicionário dados,
#não criaremos efetivamente uma cópia, mas sim um novo rótulo para o mesmo espaço na memória.

"""De modo a realmente gerarmos uma cópia na qual conseguiremos fazer alterações sem afetar o dicionário original, podemos utilizar o copy()"""

dadosCopy = dadoss.copy()
dadosCopy

dadosCopy.pop('Passat')

dadosCopy

"""## *dict.pop(key[, default ])*

Se a chave for encontrada no dicionário, o item é removido e seu valor é retornado. Caso contrário, o valor especificado como *default* é retornado. Se o valor *default* não for fornecido e a chave não for encontrada no dicionário um erro será gerado.
"""

dadosCopy.pop('Passat', 'Chave não encontrada')

dadosCopy.pop('DS5', 'Chave não encontrada')

dadosCopy

""" o método clear(), que simplesmente limpa todo o dicionário"""

dadosCopy.clear()
dadosCopy

"""## *dict.clear()*

Remove todos os itens do dicionário.
"""



"""# 3.4 Iterando em dicionários

## *dict.keys()*

Retorna uma lista contendo as chaves (*keys*) do dicionário.
"""





"""## *dict.values()*

Retorna uma lista com todos os valores (*values*) do dicionário.
"""



"""## *dict.items()*

Retorna uma lista contendo uma tupla para cada par chave-valor (*key-value*) do dicionário.
"""



"""# <font color=green> 4. FUNÇÕES E PACOTES
---
    
Funções são unidades de código reutilizáveis que realizam uma tarefa específica, podem receber alguma entrada e também podem retornar alguma resultado.

# 4.1 Built-in function

A linguagem Python possui várias funções integradas que estão sempre acessíveis. Algumas já utilizamos em nosso treinamento: type(), print(), zip(), len(), set() etc.

https://docs.python.org/3.6/library/functions.html
"""

dados = {'Jetta Variant': 88078.64, 'Passat': 106161.94, 'Crossfox': 72832.16}
dados

list(dados.values())
#cria uma lista com os valores sem ter que fazer for ou usar contador + lista vazia

sum(dados.values())
#mesma coisa, pra resolver em apenas uma linha sem contador e += soma

sum(dados.values(), 1000000)
#o parâmetro start, à direita, indica um valor inicial a partir do qual a soma será acrescentada

help(print)
#mesma coisa no R, só menorzinho de ajuda sobre funções buildt in

print?
#também funciona

"""# 4.2 Definindo funções sem e com parâmetros

### Funções sem parâmetros

#### Formato padrão

```
def <nome>():
    <instruções>
```
"""

def media():
  valor = (1 + 2 + 3) / 3
  print(valor)

media()

"""### Funções com parâmetros

#### Formato padrão

```
def <nome>(<param_1>, <param_2>, ..., <param_n>):
    <instruções>
```
"""

def media(number1, number2, number3):
  valor = (number1 + number2 + number3) / 3
  print(valor)

media(34, 67, 12)

def media(lista):
  valor = sum(lista)/len(lista)
  print(valor)

media([5,6,7,8,9,10,11,12,23,45]) #lembrar da sintaxe de parenteses e colchetes

"""### Funções que retornam um valor

#### Formato padrão

```
def <nome>(<param_1>, <param_2>, ..., <param_n>):
    <instruções>
    return <resultado>
```
"""

def media(lista):
  valor = sum(lista)/len(lista)
  return valor

media([2,7,9,8,7,6,5,4,3])
resultado = media([2,7,9,8,7,6,5,4,3])
resultado

def media(lista):
  valor = sum(lista)/len(lista)
  return (valor, len(lista)) #aqui eu estabeleco o que eu quero que a função retorne

resultado = media([2,7,9,8,7,6,5,4,3])
resultado # o resultado vai respeitar a ordem que eu coloquei acima

resultado, n = media([2,7,9,8,7,6,5,4,3])
resultado #vai ser a média
n #vai ser o len da lista, agora salvos em uma variável

#exercicio alura
dados = {
    'Crossfox': {'km': 35000, 'ano': 2005},
    'DS5': {'km': 17000, 'ano': 2015},
    'Fusca': {'km': 130000, 'ano': 1979},
    'Jetta': {'km': 56000, 'ano': 2011},
    'Passat': {'km': 62000, 'ano': 1999}
}

def km_media(dataset, ano_atual):
    result = {}
    for item in dataset.items():
        media = item[1]['km'] / (ano_atual - item[1]['ano'])
        item[1].update({ 'km_media': round(media) })
        result.update({ item[0]: item[1] })
    return result

km_media(dados, 2023)

"""Nesta aula, aprendemos:

A utilizar built-in functions no Python

A consultar a documentação do Python

Como definir funções com e sem o uso de argumentos

Como definir funções que retornam valores

### Funções que retornam mais de um valor

#### Formato padrão

```
def <nome>(<param_1>, <param_2>, ..., <param_n>):
    <instruções>
    return (<resultado_1>, <resultado_2>, ..., <resultado_n>)
```
"""











"""# <font color=green> 5. PANDAS BÁSICO
---

**versão: 0.25.2**
  
Pandas é uma ferramenta de manipulação de dados de alto nível, construída com base no pacote Numpy. O pacote pandas possui estruturas de dados bastante interessantes para manipulação de dados e por isso é muito utilizado por cientistas de dados.


## Estruturas de Dados

### Series

Series são arrays unidimensionais rotulados capazes de armazenar qualquer tipo de dado. Os rótulos das linhas são chamados de **index**. A forma básica de criação de uma Series é a seguinte:


```
    s = pd.Series(dados, index = index)
```

O argumento *dados* pode ser um dicionário, uma lista, um array Numpy ou uma constante.

### DataFrames

DataFrame é uma estrutura de dados tabular bidimensional com rótulos nas linha e colunas. Como a Series, os DataFrames são capazes de armazenar qualquer tipo de dados.


```
    df = pd.DataFrame(dados, index = index, columns = columns)
```

O argumento *dados* pode ser um dicionário, uma lista, um array Numpy, uma Series e outro DataFrame.

**Documentação:** https://pandas.pydata.org/pandas-docs/version/0.25/

# 5.1 Estruturas de dados
"""

s = pd.Series(dados, index = index)

"""### Criando uma Series a partir de uma lista"""

df = pd.DataFrame(dados, index = index, columns = columns)

import pandas as pd

carros = ['Jetta Variant', 'Passat', 'Crossfox']
carros

pd.Series(carros)

"""### Criando um DataFrame a partir de uma lista de dicionários"""

dados = [
    {'Nome': 'Jetta Variant', 'Motor': 'Motor 4.0 Turbo', 'Ano': 2003, 'Quilometragem': 44410.0, 'Zero_km': False, 'Valor': 88078.64},
    {'Nome': 'Passat', 'Motor': 'Motor Diesel', 'Ano': 1991, 'Quilometragem': 5712.0, 'Zero_km': False, 'Valor': 106161.94},
    {'Nome': 'Crossfox', 'Motor': 'Motor Diesel V8', 'Ano': 1990, 'Quilometragem': 37123.0, 'Zero_km': False, 'Valor': 72832.16}
]

dataset = pd.DataFrame(dados)
dataset

dataset[['Nome', 'Motor', 'Ano', 'Quilometragem', 'Zero_km', 'Valor']]

"""### Criando um DataFrame a partir de um dicionário"""

dados = {
    'Nome': ['Jetta Variant', 'Passat', 'Crossfox'],
    'Motor': ['Motor 4.0 Turbo', 'Motor Diesel', 'Motor Diesel V8'],
    'Ano': [2003, 1991, 1990],
    'Quilometragem': [44410.0, 5712.0, 37123.0],
    'Zero_km': [False, False, False],
    'Valor': [88078.64, 106161.94, 72832.16]
}

dataset = pd.DataFrame(dados)
dataset

import pandas as pd

dataset = pd.read_csv('db.csv', sep = ';', index_col = 0)
dataset

from google.colab import drive
drive.mount('/content/drive')

!ls

"""### Criando um DataFrame a partir de uma arquivo externo"""



"""# 5.2 Seleções com DataFrames

### Selecionando colunas
"""

dataset.head()
#mostra os 5 primeiros registros do dataframe

dataset['Valor']
#dessa forma eu retorno uma coluna como series

type(dataset['Valor'])

dataset[['Valor']]
#dessa forma eu retorno o fatiamento da coluna como um DataFrame

"""### Selecionando linhas - [ i : j ]

<font color=red>**Observação:**</font> A indexação tem origem no zero e nos fatiamentos (*slices*) a linha com índice i é **incluída** e a linha com índice j **não é incluída** no resultado.
"""

#funciona da mesma forma que o fatiamento de string
dataset[:3]

"""### Utilizando .loc para seleções

<font color=red>**Observação:**</font> Seleciona um grupo de linhas e colunas segundo os rótulos ou uma matriz booleana.
"""

#forma mais sofisticada e que permite fatiamentos mais semânticos, pois a seleção é feita a partir dos rótulos
dataset.loc['Passat']
#da mesma forma que a seleção de colunas anterior, ele retorna uma series

dataset.loc[['Passat', 'DS5']]
#para retornar um dataframe

#para selecionar linhas e colunas como dataframe
dataset.loc[['Passat', 'DS5'], ['Motor', 'Valor']]

dataset.loc[:, ['Motor', 'Valor']]
#da mesma forma que o fatiamento de string, os : selecionam tudo, do 0 ao -1

"""### Utilizando .iloc para seleções

<font color=red>**Observação:**</font> Seleciona com base nos índices, ou seja, se baseia na posição das informações.
"""

dataset.iloc[1]
#seleciona pelo índice e retorna uma series

dataset.iloc[[1]] #retorna dataframe

dataset.iloc[1:4] #para retornar multiplas linhas

dataset.iloc[:, [0,5,2]] #aqui eu retornei todas as linhas, mas apenas 3 colunas

dataset.iloc[[1, 42, 22], [0, 5, 2]]

"""# 5.3 Queries com DataFrames"""

dataset.Motor
#método que só funciona quando os rótulos não tem espaço, o retorno é uma series

dataset.Motor == 'Motor Diesel'
#usar aspas simples, retorno é um boleano

select = dataset.Motor == 'Motor Diesel'
type(select)
#para retornar como DataFrame, eu armazeno numa variável e depois chamo com os colchetes

dataset[select]

#para queries com seleções adicionais
dataset[(dataset.Motor == 'Motor Diesel')&(dataset.Zero_km == True)]
#o & significa E

(dataset.Motor == 'Motor Diesel') & (dataset.Zero_km == True)
#essa consulta é uma series boleana

"""### Utilizando o método query"""

dataset.query('Motor == "Motor Diesel" and Zero_km == True')
#observar a regra de aspas duplas dentro de aspas simples, no método query os operadores lógicos são AND e OR

"""# 5.4 Iterando com DataFrames"""

dataset.head()
#para iterar em datasets pequenos, pode usar FOR/IF e iterrows, para datasets grandes esses métodos são lentos, existem outros

for item in dataset:
    print(item)

#isso retorna os rótulos do dataframe

#iterrows é um iterador, passando ele em todo dataset, ele cria tuplas com as informações da linha com as colunas, tipo um arquivo json
list(dataset.iterrows())

#for com iterrows para desempacotar as tuplas em infos específicas
for index, row in dataset.iterrows():
  if(2019 - row['Ano'] != 0): # 1
    dataset.loc[index, 'Km_media'] = row['Quilometragem'] / (2019 - row['Ano'])  #2
  else:
    dataset.loc[index, 'Km_media'] = 0 #3

dataset
#1 - o row chama as linhas pelo nome, não pelo index numérico, aqui eu estou apenas os carros que não são do ano, senão tenho erro de div por zero
#2 - aqui estou criando uma nova coluna com a quilometragem média
#3 - aqui eu faço um tratamento final para evitar div por zero

"""# 5.5 Tratamento de dados"""

dataset.info()
#percebi muitos NA na coluna quilometragem

#seleciona informações nulas ou não
dataset.Quilometragem.isna()
#devolve uma series booleana identificando quais valores são ou não "NA" (nulos, vazios e assim por diante).

dataset[dataset.Quilometragem.isna()]
#cria um seletor só com o que eu quero, nesse caso, os NA

dataset.fillna(0, inplace = True)
#quero preencher os NA com zero, mas preciso do inplace para modificar o dataset de fato, senão eu apenas altero a visualização

dataset = pd.read_csv('db.csv', sep = ';')

dataset = pd.read_csv('db.csv', sep = ';')
#subset, recebe a variável na qual queremos queremos buscar os valores nulos que serão eliminados.

dataset.dropna(subset = ['Quilometragem'], inplace = True)
#dessa forma eu elimino tudo e com o inplace eu garanto que o dataset será alterado